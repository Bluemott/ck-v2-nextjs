---
name: nextjs-aws-optimization.mdc
description: Next.js best practices optimized for AWS deployment and performance
globs: ***/**.{ts,tsx,js,jsx}
---
- Use App Router with static generation (generateStaticParams) to minimize Lambda cold starts
- Implement ISR (Incremental Static Regeneration) for dynamic content to reduce server costs
- Leverage Next.js Image Optimization with CloudFront for automatic WebP conversion and caching
- Use middleware sparingly to avoid additional Lambda invocations; prefer static edge functions
- Configure output: 'standalone' for smaller Docker images in ECS/Fargate deployments
- Implement proper caching headers to maximize CloudFront cache hit ratios
- Use dynamic imports and code splitting to reduce bundle sizes and improve cold start times

---
name: aws-serverless-best-practices.mdc
description: AWS serverless optimization for cost and performance
globs: ***/**.{ts,tsx,js,jsx}
---
- Minimize Lambda function size by using tree shaking and excluding dev dependencies
- Implement connection reuse for database connections (RDS Proxy for relational DBs)
- Use DynamoDB single-table design patterns to reduce costs and improve performance
- Leverage Lambda@Edge for global content delivery and reduced latency
- Implement proper error handling to avoid unnecessary Lambda retries and costs
- Use AWS SDK v3 with modular imports to reduce bundle size
- Configure appropriate memory allocation for Lambda functions to optimize cost/performance ratio
- Use provisioned concurrency only for high-traffic, latency-sensitive functions

---
name: typescript-aws-integration.mdc
description: TypeScript patterns for AWS services with type safety
globs: ***/**.{ts,tsx}
---
- Use AWS SDK v3 types for better IntelliSense and compile-time error checking
- Create strict types for DynamoDB items and API Gateway responses
- Implement proper error types for AWS service exceptions
- Use utility types for AWS resource configurations (CloudFormation, CDK)
- Define environment variable types with proper validation using zod or similar
- Create reusable type definitions for common AWS patterns (Lambda events, S3 objects)
- Use conditional types for service-specific configurations

---
name: tailwindcss-performance-optimization.mdc
description: Tailwind CSS optimization for faster builds and smaller bundles
globs: ***/**.{ts,tsx,css}
---
- Configure JIT mode and purge unused styles to minimize CSS bundle size
- Use Tailwind's container queries and dynamic viewports for responsive AWS CloudFront delivery
- Implement CSS-in-JS alternatives like styled-components only when necessary for SSR
- Leverage Tailwind's built-in dark mode for reduced JavaScript bundle size
- Use Tailwind plugins sparingly to avoid build-time performance issues
- Configure proper content paths to ensure efficient purging in CI/CD pipelines
- Use CSS custom properties for theme values that need runtime changes

---
name: aws-data-fetching-patterns.mdc
description: Optimized data fetching patterns for AWS services
globs: ***/**.{ts,tsx}
---
- Use React Query/TanStack Query with proper caching strategies to reduce API calls
- Implement optimistic updates to improve perceived performance
- Use SWR or similar for client-side data fetching with built-in retry logic
- Leverage Next.js streaming and Suspense for improved loading states
- Implement proper error boundaries for AWS service failures
- Use GraphQL with AWS AppSync for real-time data synchronization
- Cache API responses in Redis/ElastiCache for frequently accessed data
- Implement request deduplication to avoid duplicate AWS API calls

---
name: aws-security-and-monitoring.mdc
description: Security and monitoring best practices for AWS deployments
globs: ***/**.{ts,tsx,js,jsx}
---
- Use AWS IAM roles with least privilege principle for all services
- Implement proper input validation and sanitization for all user inputs
- Use AWS Secrets Manager or Parameter Store for sensitive configuration
- Enable AWS CloudTrail and CloudWatch for comprehensive monitoring
- Implement structured logging with correlation IDs for distributed tracing
- Use Content Security Policy (CSP) headers for XSS protection
- Enable AWS WAF for API Gateway and CloudFront distributions
- Implement rate limiting to prevent abuse and control costs

---
name: react-aws-performance.mdc
description: React optimization patterns for AWS environments
globs: ***/**.{ts,tsx}
---
- Use React.lazy with Suspense for code splitting aligned with Lambda function boundaries
- Implement proper memoization (useMemo, useCallback) to reduce re-renders in serverless environments
- Use React Query's background refetching to keep data fresh without blocking UI
- Implement virtualization for large lists to reduce memory usage in client-side rendering
- Use React Server Components where possible to reduce client bundle size
- Implement proper loading states that work well with CloudFront caching
- Use React's concurrent features (useTransition, useDeferredValue) for better UX
- Optimize component re-renders to minimize hydration mismatches in SSR

---
name: aws-cost-optimization.mdc
description: Cost optimization strategies for AWS services
globs: ***/**.{ts,tsx,js,jsx,json,yml,yaml}
---
- Use AWS Cost Explorer APIs to implement cost monitoring in applications
- Implement proper CloudWatch log retention policies to control storage costs
- Use S3 lifecycle policies for static assets and user uploads
- Configure appropriate auto-scaling policies for ECS/Fargate services
- Implement request batching for DynamoDB operations to reduce consumed capacity
- Use CloudFront caching strategies to minimize origin requests
- Monitor and optimize Lambda function duration to reduce execution costs
- Use Spot instances for development and non-critical workloads
- Implement proper resource tagging for cost allocation and monitoring

---
name: eslint-aws-focused.mdc
description: ESLint configuration optimized for AWS development
globs: ***/**.{ts,tsx,js,jsx}
---
- Enable AWS SDK-specific linting rules to catch common mistakes
- Use eslint-plugin-security to identify potential security vulnerabilities
- Configure rules for proper async/await usage in Lambda functions
- Enable rules for environment variable validation and usage
- Use custom rules for consistent error handling patterns across AWS services
- Configure rules to enforce proper logging patterns for CloudWatch
- Enable rules for consistent naming conventions for AWS resources
- Use rules to enforce proper TypeScript usage with AWS SDK types

---
name: aws-infrastructure-as-code.mdc
description: Best practices for AWS CDK and infrastructure management
globs: ***/**.{ts,js,yml,yaml,json}
---
- Use AWS CDK constructs for consistent resource creation and management
- Implement proper stack separation (dev/staging/prod) with parameter overrides
- Use CDK aspects for cross-cutting concerns like tagging and security policies
- Implement proper secret management with AWS Secrets Manager integration
- Use CloudFormation outputs for cross-stack resource sharing
- Implement proper backup and disaster recovery strategies in IaC
- Use CDK pipelines for automated deployment and rollback capabilities
- Configure proper monitoring and alerting through CloudWatch in IaC templates
